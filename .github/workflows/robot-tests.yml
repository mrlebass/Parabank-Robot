name: Web Regressive E2E

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

  workflow_dispatch:
    inputs:
      mode:
        description: "Modo de execução"
        type: choice
        required: true
        default: parallel
        options:
          - parallel
          - single

      # ✅ seleção livre (checkbox) — funciona como “selection button”
      run_login:
        description: "Rodar feature Login?"
        type: boolean
        required: true
        default: true
      run_transfer:
        description: "Rodar feature Transfer?"
        type: boolean
        required: true
        default: true
      run_billpay:
        description: "Rodar feature BillPay?"
        type: boolean
        required: true
        default: true
      run_opennewaccount:
        description: "Rodar feature OpenNewAccount?"
        type: boolean
        required: true
        default: true
      run_updateprofile:
        description: "Rodar feature UpdateProfile?"
        type: boolean
        required: true
        default: true

      tag_filter:
        description: "Filtro por tag"
        type: choice
        required: true
        default: all
        options:
          - all
          - positive
          - negative
          - custom

      custom_tags:
        description: "Se tag_filter=custom: informe tags separadas por vírgula (ex: Positive,Smoke)"
        required: false
        default: ""

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # =========================
  # PREPARE: decide suites + tags + mode
  # (sempre roda e gera outputs válidos)
  # =========================
  prepare:
    runs-on: ubuntu-latest
    outputs:
      run_mode: ${{ steps.build.outputs.run_mode }}
      matrix_json: ${{ steps.build.outputs.matrix_json }}
      single_args: ${{ steps.build.outputs.single_args }}
      tag_args: ${{ steps.build.outputs.tag_args }}
    steps:
      - name: Build matrix + tag args
        id: build
        shell: bash
        run: |
          set -e

          python - <<'PY' > prepared.txt
          import os, json

          event = os.environ.get("GITHUB_EVENT_NAME", "")
          # default para push/pr
          run_mode = "parallel"
          selected = {
            "Resources/Login": True,
            "Resources/Transfer": True,
            "Resources/BillPay": True,
            "Resources/OpenNewAccount": True,
            "Resources/UpdateProfile": True,
          }

          # workflow_dispatch: usa inputs (checkbox)
          if event == "workflow_dispatch":
            run_mode = os.environ.get("INPUT_MODE", "parallel")
            selected = {
              "Resources/Login": os.environ.get("INPUT_RUN_LOGIN", "true") == "true",
              "Resources/Transfer": os.environ.get("INPUT_RUN_TRANSFER", "true") == "true",
              "Resources/BillPay": os.environ.get("INPUT_RUN_BILLPAY", "true") == "true",
              "Resources/OpenNewAccount": os.environ.get("INPUT_RUN_OPENNEWACCOUNT", "true") == "true",
              "Resources/UpdateProfile": os.environ.get("INPUT_RUN_UPDATEPROFILE", "true") == "true",
            }

          suites = [p for p, ok in selected.items() if ok]

          # se o usuário desmarcar tudo, evita quebrar:
          if not suites:
            suites = ["Resources/Login"]

          # tags
          tag_filter = os.environ.get("INPUT_TAG_FILTER", "all")
          custom = os.environ.get("INPUT_CUSTOM_TAGS", "").strip()

          # Robot: -i TAG (include)
          tag_args = ""
          if event == "workflow_dispatch":
            if tag_filter == "positive":
              tag_args = "-i Positive"
            elif tag_filter == "negative":
              tag_args = "-i Negative"
            elif tag_filter == "custom" and custom:
              tags = [t.strip() for t in custom.split(",") if t.strip()]
              tag_args = " ".join([f"-i {t}" for t in tags])

          # matrix (parallel) com slug seguro
          matrix = []
          for s in suites:
            slug = s.replace("/", "-")
            matrix.append({"path": s, "slug": slug})

          # single args: Robot aceita múltiplas pastas no fim do comando
          single_args = " ".join(suites)

          # imprime num JSON único para o bash exportar
          payload = {
            "run_mode": run_mode,
            "matrix_json": json.dumps({"include": matrix}),
            "single_args": single_args,
            "tag_args": tag_args
          }
          print(json.dumps(payload))
          PY

          cat prepared.txt

          # export outputs com heredoc (forma correta)
          RUN_MODE=$(cat prepared.txt | python -c "import sys,json; print(json.load(sys.stdin)['run_mode'])")
          MATRIX=$(cat prepared.txt | python -c "import sys,json; print(json.load(sys.stdin)['matrix_json'])")
          SINGLE_ARGS=$(cat prepared.txt | python -c "import sys,json; print(json.load(sys.stdin)['single_args'])")
          TAG_ARGS=$(cat prepared.txt | python -c "import sys,json; print(json.load(sys.stdin)['tag_args'])")

          {
            echo "run_mode=$RUN_MODE"
            echo "matrix_json<<EOF"
            echo "$MATRIX"
            echo "EOF"
            echo "single_args<<EOF"
            echo "$SINGLE_ARGS"
            echo "EOF"
            echo "tag_args<<EOF"
            echo "$TAG_ARGS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

  # =========================
  # PARALLEL (auto e manual): roda cada feature em um job (matrix)
  # push/pr: sempre parallel ALL
  # manual: parallel com checkboxes
  # =========================
  robot-parallel:
    needs: [prepare]
    if: ${{ needs.prepare.outputs.run_mode == 'parallel' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.prepare.outputs.matrix_json) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Install Google Chrome
        run: |
          sudo apt-get update
          sudo apt-get install -y wget gnupg
          wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo gpg --dearmor -o /usr/share/keyrings/google-linux-keyring.gpg
          echo "deb [arch=amd64 signed-by=/usr/share/keyrings/google-linux-keyring.gpg] http://dl.google.com/linux/chrome/deb/ stable main" | sudo tee /etc/apt/sources.list.d/google-chrome.list
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable

      - name: Run Robot (headless) - parallel
        shell: bash
        env:
          TAG_ARGS: ${{ needs.prepare.outputs.tag_args }}
        run: |
          set +e
          OUT="Results/${{ matrix.slug }}"
          mkdir -p "$OUT"

          echo "Running suite: ${{ matrix.path }}"
          echo "TAG_ARGS: $TAG_ARGS"

          # shellcheck disable=SC2086
          robot -d "$OUT" -v HEADLESS:True $TAG_ARGS "${{ matrix.path }}"
          exit_code=$?
          echo "robot_exit_code=$exit_code" >> $GITHUB_OUTPUT
          set -e
          exit $exit_code

      - name: Upload artifacts (per suite)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: robot-results-${{ matrix.slug }}
          path: |
            Results/${{ matrix.slug }}/**
          if-no-files-found: warn
          retention-days: 14

  # =========================
  # SINGLE (manual): 1 job só, mas roda as features selecionadas em sequência
  # =========================
  robot-single:
    needs: [prepare]
    if: ${{ github.event_name == 'workflow_dispatch' && needs.prepare.outputs.run_mode == 'single' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Install Google Chrome
        run: |
          sudo apt-get update
          sudo apt-get install -y wget gnupg
          wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo gpg --dearmor -o /usr/share/keyrings/google-linux-keyring.gpg
          echo "deb [arch=amd64 signed-by=/usr/share/keyrings/google-linux-keyring.gpg] http://dl.google.com/linux/chrome/deb/ stable main" | sudo tee /etc/apt/sources.list.d/google-chrome.list
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable

      - name: Run Robot (headless) - single
        shell: bash
        env:
          TAG_ARGS: ${{ needs.prepare.outputs.tag_args }}
          SUITES: ${{ needs.prepare.outputs.single_args }}
        run: |
          set +e
          OUT="Results/single"
          mkdir -p "$OUT"

          echo "Running suites (single job): $SUITES"
          echo "TAG_ARGS: $TAG_ARGS"

          # shellcheck disable=SC2086
          robot -d "$OUT" -v HEADLESS:True $TAG_ARGS $SUITES
          exit_code=$?
          set -e
          exit $exit_code

      - name: Upload artifacts (single)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: robot-results-single
          path: |
            Results/single/**
          if-no-files-found: warn
          retention-days: 14

  # =========================
  # PAGES: publica SEMPRE (mesmo com falhas)
  # Observação: nesse modelo, o site é "latest" (sobrescreve a cada deploy).
  # =========================
  publish-pages:
    needs: [prepare, robot-parallel, robot-single]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: _artifacts

      - name: Build Pages site (latest)
        shell: bash
        run: |
          mkdir -p site/latest

          # Mantém cada artifact em sua própria pasta (evita colisão de log.html/report.html)
          cp -R _artifacts/* site/latest/ 2>/dev/null || true

          # Index
          cat > site/index.html <<'HTML'
          <!doctype html>
          <html>
            <head>
              <meta charset="utf-8">
              <title>Robot Reports</title>
              <style>
                body { font-family: Arial, sans-serif; padding: 20px; }
                code { background: #eee; padding: 2px 6px; border-radius: 6px; }
              </style>
            </head>
            <body>
              <h2>Robot Framework - Latest Run</h2>
              <p>Abra um artifact e entre em <code>log.html</code> / <code>report.html</code> dentro dele.</p>
              <p><b>Pastas:</b></p>
              <ul id="list"></ul>
              <script>
                // lista pastas por “convenção”: link direto exige saber o nome da pasta
                // (GitHub Pages não deixa listar diretório nativamente sem gerar index por pasta)
                document.getElementById('list').innerHTML =
                  '<li>Abra: <a href="latest/">latest/</a> (veja as pastas)</li>';
              </script>
            </body>
          </html>
          HTML

      - name: Configure Pages
        uses: actions/configure-pages@v5

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: site

      - name: Deploy to GitHub Pages
        uses: actions/deploy-pages@v4
